import comp from "/Users/kuailingmin/Desktop/klm/stars-vuepress/docs/.vuepress/.temp/pages/java/hash.html.vue"
const data = JSON.parse("{\"path\":\"/java/hash.html\",\"title\":\"HashMap,HashTable,ConcurrentHashMap\",\"lang\":\"zh-CN\",\"frontmatter\":{},\"git\":{\"updatedTime\":1722322323000,\"contributors\":[{\"name\":\"前端艺术者\",\"username\":\"\",\"email\":\"kuailingmin@126.com\",\"commits\":1}],\"changelog\":[{\"hash\":\"444e0c9033fc5359522e4a4695075e0e365d6291\",\"time\":1722322323000,\"email\":\"kuailingmin@126.com\",\"author\":\"前端艺术者\",\"message\":\"新增内容\"}]},\"filePathRelative\":\"java/hash.md\",\"excerpt\":\"\\n<h3>一、非线程安全的HashMap</h3>\\n<blockquote>\\n<ul>\\n<li><code>jdk1.7</code> 的 <code>HashMap</code> 的底层实现是 <strong>数组</strong> + <strong>单向链表</strong>，支持key为 <code>null</code>，value 为<code>null</code>。</li>\\n<li>它的初始容量是 <code>16</code>，负载因子默认值 <code>0.75</code>，当实际存放元素数量大于等于 <strong>阈值</strong>，（而且新元素被放入的哈希槽不为空），那么就会触发扩容，每次扩容时的容量都是翻倍增长（一定是 <code>2</code>的次幂）,所以在实例存储元素项较多的情况下，一定要指定初始容量，避免每次扩容带来性能上的影响。</li>\\n<li><strong>负载因子</strong> 取值问题也是一个重要原因，取值越大<strong>哈希冲突</strong> 的概率就越高，取值越小空间浪费度就越高。而 <code>0.75</code> 是一个比较折中的选择。</li>\\n<li>其属性、方法、代码块没有被 <code>synchronize</code>修饰，也没有使用其他同步机制，在多线程环境下是 <strong>非线程安全</strong>的。</li>\\n</ul>\\n</blockquote>\"}")
export { comp, data }
