import{_ as t,c as e,a as s,e as p,w as o,r as c,o as l,d as i}from"./app-D755Bb6P.js";const u="/assets/event-4YNa9kHE.png",r={};function k(m,n){const a=c("font");return l(),e("div",null,[n[1]||(n[1]=s('<h1 id="事件循环" tabindex="-1"><a class="header-anchor" href="#事件循环"><span>事件循环</span></a></h1><div class="hint-container tip"><p class="hint-container-title">说明</p><p>笔记一下 Event Loop中 宏任务（macrotask ）和 微任务（microtask ），macrotask 和 microtask 表示异步任务的两种分类。挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，首先在 macrotask 的队列（这个队列也被叫做 task queue）中取出第一个任务，执行完毕后取出 microtask 队列中的所有任务顺序执行；之后再取 macrotask 任务，周而复始，直至两个队列的任务都取完。</p></div><h3 id="执行优先级限制" tabindex="-1"><a class="header-anchor" href="#执行优先级限制"><span>执行优先级限制</span></a></h3><p>并不止一个消息队列，有异步队列和事件队列，而事件队列总是优先于异步队列被空闲下来的JS线程取用</p><ul><li>宏任务：script中代码，setTimeout，setInterval、I/O、UI render</li><li>微任务：Promise、Object.observe、MutationObserver</li></ul>',5)),p(a,{color:"red",face:"黑体"},{default:o(()=>[...n[0]||(n[0]=[i("注:Object.observe好像被废弃了，有文章还说到Angular 2团队曾经实验性的使用了 O.o，但是因为性能原因最终放弃了",-1)])]),_:1}),n[2]||(n[2]=s('<p><a href="https://github.com/luokuning/blogs/issues/1" target="_blank" rel="noopener noreferrer">点击查看具体原因</a></p><p>宏任务和微任务之间的关系图： <img src="'+u+`" alt=""></p><p>代码体现:</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line">  <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;外层宏事件2&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;微事件1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span></span>
<span class="line">      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;微事件2&#39;</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line">  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;外层宏事件1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token comment">//执行后 回调一个宏事件</span></span>
<span class="line">      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;内层宏事件3&#39;</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果：</p><ol><li>外层宏事件2</li><li>外层宏事件1</li><li>微事件1</li><li>微事件2</li><li>内层宏事件3</li></ol><h3 id="浏览器环境" tabindex="-1"><a class="header-anchor" href="#浏览器环境"><span>浏览器环境</span></a></h3><ul><li><p>浏览器环境下的 异步任务 分为 宏任务(macroTask) 和 微任务(microTask)：</p></li><li><p>宏任务(macroTask)：script 中代码、setTimeout、setInterval、I/O、UI render；</p></li><li><p>微任务(microTask)： Promise、Object.observe、MutationObserver。</p></li><li><p>当满足执行条件时，宏任务(macroTask) 和 微任务(microTask) 会各自被放入对应的队列：宏队列(Macrotask Queue) 和 微队列(Microtask Queue) 中等待执行。</p></li></ul><h3 id="node-js环境" tabindex="-1"><a class="header-anchor" href="#node-js环境"><span>node.js环境</span></a></h3><p>在 Node 环境中 任务类型 相对就比浏览器环境下要复杂一些：</p><ul><li><p>microTask：微任务；</p></li><li><p>nextTick：process.nextTick；</p></li><li><p>timers：执行满足条件的 setTimeout 、setInterval 回调；</p></li><li><p>I/O callbacks：是否有已完成的 I/O 操作的回调函数，来自上一轮的 poll 残留；</p></li><li><p>poll：等待还没完成的 I/O 事件，会因 timers 和超时时间等结束等待；</p></li><li><p>check：执行 setImmediate 的回调；</p></li><li><p>close callbacks：关闭所有的 closing handles ，一些 onclose 事件； idle/prepare 等等：可忽略。</p></li></ul><p>因此，也就产生了执行事件循环相应的任务队列 Timers Queue、I/O Queue、Check Queue 和 Close Queue。</p>`,12))])}const v=t(r,[["render",k],["__file","eventLoop.html.vue"]]),h=JSON.parse('{"path":"/knowledge/eventLoop.html","title":"事件循环","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1722322323000,"contributors":[{"name":"前端艺术者","username":"","email":"kuailingmin@126.com","commits":1}],"changelog":[{"hash":"444e0c9033fc5359522e4a4695075e0e365d6291","time":1722322323000,"email":"kuailingmin@126.com","author":"前端艺术者","message":"新增内容"}]},"filePathRelative":"knowledge/eventLoop.md","excerpt":"\\n<div class=\\"hint-container tip\\">\\n<p class=\\"hint-container-title\\">说明</p>\\n<p>笔记一下 Event Loop中 宏任务（macrotask ）和 微任务（microtask ），macrotask 和 microtask 表示异步任务的两种分类。挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，首先在 macrotask 的队列（这个队列也被叫做 task queue）中取出第一个任务，执行完毕后取出 microtask 队列中的所有任务顺序执行；之后再取 macrotask 任务，周而复始，直至两个队列的任务都取完。</p>\\n</div>"}');export{v as comp,h as data};
