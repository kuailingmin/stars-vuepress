import{_ as s,c as a,a as o,o as t}from"./app-D755Bb6P.js";const e="/assets/jvm1-B8Und0kd.png",r="/assets/jvm2-DWfb0e3s.png",l={};function c(p,n){return t(),a("div",null,[...n[0]||(n[0]=[o('<h1 id="jvm运行时数据区" tabindex="-1"><a class="header-anchor" href="#jvm运行时数据区"><span>JVM运行时数据区</span></a></h1><p><img src="'+e+'" alt="运行时数据区"></p><h4 id="线程私有的内存区域" tabindex="-1"><a class="header-anchor" href="#线程私有的内存区域"><span>👒线程私有的内存区域：</span></a></h4><ul><li>程序计数器、虚拟机栈、本地方法栈</li></ul><h4 id="线程共享的内存区域" tabindex="-1"><a class="header-anchor" href="#线程共享的内存区域"><span>🌂线程共享的内存区域：</span></a></h4><ul><li>方法区、Java堆</li></ul><h3>二、线程私有的内存区域</h3><h4 id="_2-1-程序计数器" tabindex="-1"><a class="header-anchor" href="#_2-1-程序计数器"><span>🍛2.1 程序计数器</span></a></h4><blockquote><p><strong>Program Counter</strong>，简称 <strong>PC</strong>，用于存放 <em>下一条</em> 指令所在单元的地址，是<code>线程所执行的字节码的行号指示器</code>。因为JVM的多线程是通过轮流切换来分配CPU的执行时间（时间片轮询），当切换到下一条线程的时候，<strong>线程要能知道当前要执行的字节码位置</strong>，这就要求每条线程都要有一个自己的程序计数器，独立<code>存储</code>待执行的虚拟机字节码指令的地址。</p></blockquote><h4 id="_2-2-虚拟机栈" tabindex="-1"><a class="header-anchor" href="#_2-2-虚拟机栈"><span>🍮2.2 虚拟机栈</span></a></h4><p><img src="'+r+`" alt="虚拟机栈"></p><blockquote><p><strong>虚拟机栈</strong>生命周期同线程,所以不必担心垃圾回收问题。**虚拟机栈(VM Stack)**这个内存区域对应的是每个线程class方法执行的内存模型（不仅Java，像Kotlin、Scala、Groovy等于都可以编译成class文件并允许在JVM上）。线程中的每个方法在执行的同时都会创建一个 <strong>栈帧（Stack Frame）</strong>。每个class方法从<code>被调用</code>到<code>执行完成</code>的过程，都对应着一个栈帧在虚拟机栈从<code>入栈</code>到<code>出栈</code>的过程。</p></blockquote><blockquote><p><strong>栈帧</strong>是用来<strong>存储</strong> <strong>（方法内的）局部变量表、（计算时的）操作数栈、（引用的）动态链接、（进入或退出方法时的）方法出入口</strong>等。</p><ul><li><strong>局部变量表</strong>：存放 <strong>编译期</strong> 可知的数据类型，包括 <strong>基本数据类型</strong>（boolean、byte、char、short、int、long、float、double）、<strong>对象引用</strong>（reference类型）、<strong>returnAddress类型</strong>（指向一条字节码指令的地址）。每个 **局部变量空间（slot）**的长度是 <strong>32位</strong>，而 <strong>long</strong>、<strong>double</strong>类型的每个变量占用 <strong>2个局部变量空间</strong>，也就是会占用64位空间。局部变量表所需的内存大小在编译期就已经确定，并记录在class文件中。</li><li><strong>操作数栈</strong>：栈是一个先进后出的线性表，操作数栈是逻辑计算的数据容器，比如下面的计算：</li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line">retuen c<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><h4 id="_2-3本地方法栈" tabindex="-1"><a class="header-anchor" href="#_2-3本地方法栈"><span>🍈2.3本地方法栈</span></a></h4><blockquote><p>本地方法栈和虚拟机栈相似，只不过虚拟机栈是用于线程中执行Java方法（字节码，因为还有Scala、Kotlin、Groovy等其他运行在虚拟机上的编程语言），本地方法栈是用于执行本地的 <strong>native方法</strong> 。</p></blockquote><h3>三、线程共享的内存区域</h3><h4 id="_3-1-堆" tabindex="-1"><a class="header-anchor" href="#_3-1-堆"><span>🍊3.1 堆</span></a></h4><blockquote><p>堆Heap又称 <strong>Java堆</strong>，这个内存区域是JVM线程共享的区域，也是JVM管理的最大一块内存区域。堆内存区域创建于JVM启动时。</p><p><strong>堆</strong>的 <strong>唯一</strong> 目的就是存放 <strong>实例对象</strong>，反之不成立，也就是说有少量的对象实例并不在Java堆中存放，也可以在栈上分配，<strong>Java堆仅存放绝大量的对象实例</strong>。</p></blockquote><blockquote><p><strong>Java堆</strong> 不像 栈 那样，随线程而生、随线程而亡。Java堆中的实例对象可能被多个线程中的变量所引用，一个线程死亡，而其他线程还可能正使用此实例对象，所以 <strong>Java堆</strong> 成为垃圾收集器收集垃圾一个重要的区域（宏观来讲是垃圾收集器管理的主要区域）。</p></blockquote><blockquote><p>现在主流的垃圾收集器采用 <strong>分代收集算法</strong>，堆内存又被细分为<strong>新生代(Young Generation)</strong> 和 <strong>老年代(Old Generation)</strong>(默认比: 1:2)。<strong>新生代</strong> 再细分为：1个<strong>Eden空间</strong>和<strong>2个Survivor空间</strong>（默认比例8:1:1）,2个Survivor空间其中一个是<strong>From Survivor空间</strong>和一个<strong>To Survivor 空间</strong>。<strong>分代分空间的唯一理由就是优化GC性能</strong>。具体jvm查看命令可参考<a href="https://github.com/about-cloud/JavaCore" target="_blank" rel="noopener noreferrer">jvm内存分析命令文章</a>)</p></blockquote><blockquote><p>常量池</p><ul><li><strong>静态常量池</strong>：即*.class文件中的常量池，class文件中的常量池不仅仅包含<strong>字符串(数值)字面量</strong>，还包含<strong>类、方法的信息</strong>，占用class文件绝大部分空间；</li><li><strong>运行时常量池</strong>：则是JVM虚拟机在完成 <strong>类装载</strong> 操作后，将class文件中的常量池载入到内存中，并保存在 <strong>方法区</strong> 中，我们常说的 <strong>常量池，就是指方法区中的运行时常量池，存放在字面量和符号引用</strong>。</li></ul></blockquote><h4 id="_3-2方法区" tabindex="-1"><a class="header-anchor" href="#_3-2方法区"><span>🍓3.2方法区</span></a></h4><blockquote><p>方法区用来<code>存储</code>类信息（类的版本、接口描述）、常量、静态变量、方法（数据与编译后代码）等数据，也有一些方法区的数据生命周期长，进而将方法区称为“永久代（Permanent Generation）”，永久存在不被GC回收，但本质上并不相等。方法区在逻辑上是和Java堆相连的，该区域一般GC很少参与，偶尔会存在对不使用的常量进行内存回收，对于一些卸载的类进行资源回收，因为这些数据占用内存本来就比较少，所以GC的回收效果也非常的一般。</p></blockquote><ul><li>JDK1.6的永久代（PermGen）</li><li>JDK1.7的永久代（PermGen）（过度阶段）</li><li>JDK1.8的元空间（Metaspace）（直接内存）</li></ul><blockquote><p>用jdk1.6运行后会报错，永久代这个区域内存溢出会报： Exception in thread “main” java.lang.OutOfMemoryError:PermGen space的内存溢出异常，表示永久代内存溢出。</p><p>在Java7之前，HotSpot虚拟机中将GC分代收集扩展到了方法区，使用永久代来实现了方法区。这个区域的内存回收目标主要是 <strong>针对常量池的回收和对类型的卸载</strong>。但是在之后的HotSpot虚拟机实现中，逐渐开始将方法区从永久代移除。Java7中已经将运行时常量池从永久代移除，在Java 堆（Heap）中开辟了一块区域存放运行时常量池。而在Java8中，已经彻底没有了永久代，将方法区直接放在一个与堆不相连的本地内存区域，这个区域被叫做<strong>元空间（MetaSpace）</strong>。</p><p>使用jdk1.7后 验证如下：执行代码和上面相同 设置参数：-Xmx20m -Xms20m -XX:-UseGCOverheadLimit，这里的-XX:-UseGCOverheadLimit是关闭GC占用时间过长时会报的异常，然后限制堆的大小，运行程序，果然，一会后报异常：</p><p>Exception in thread “main” java.lang.OutOfMemoryError: Java heap space 从上面的异常可以知道我们测试增加的常量都放到了堆中，所以限制堆内存以后，不断增加常量，堆内存会溢出。</p></blockquote><blockquote><p>总结：<strong>jdk1.6常量池放在方法区，jdk1.7常量池放在堆内存，jdk1.8放在元空间里面，和堆相独立。所以导致String的intern()方法因为以上变化在不同版本会有不同表现。</strong></p></blockquote>`,26)])])}const g=s(l,[["render",c],["__file","jvmTime.html.vue"]]),d=JSON.parse('{"path":"/java/jvmTime.html","title":"JVM运行时数据区","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1722322323000,"contributors":[{"name":"前端艺术者","username":"","email":"kuailingmin@126.com","commits":1}],"changelog":[{"hash":"444e0c9033fc5359522e4a4695075e0e365d6291","time":1722322323000,"email":"kuailingmin@126.com","author":"前端艺术者","message":"新增内容"}]},"filePathRelative":"java/jvmTime.md","excerpt":"\\n<p></p>\\n<h4>👒线程私有的内存区域：</h4>\\n<ul>\\n<li>程序计数器、虚拟机栈、本地方法栈</li>\\n</ul>\\n<h4>🌂线程共享的内存区域：</h4>\\n<ul>\\n<li>方法区、Java堆</li>\\n</ul>\\n<h3>二、线程私有的内存区域</h3>\\n<h4>🍛2.1 程序计数器</h4>\\n<blockquote>\\n<p><strong>Program Counter</strong>，简称 <strong>PC</strong>，用于存放 <em>下一条</em> 指令所在单元的地址，是<code>线程所执行的字节码的行号指示器</code>。因为JVM的多线程是通过轮流切换来分配CPU的执行时间（时间片轮询），当切换到下一条线程的时候，<strong>线程要能知道当前要执行的字节码位置</strong>，这就要求每条线程都要有一个自己的程序计数器，独立<code>存储</code>待执行的虚拟机字节码指令的地址。</p>\\n</blockquote>"}');export{g as comp,d as data};
